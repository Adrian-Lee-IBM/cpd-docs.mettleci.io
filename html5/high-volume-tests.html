<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2024"><meta name="generator" content="DITA-OT"><title>High Volume DataStage Tests</title><link rel="stylesheet" type="text/css" href="commonltr.css"></head><body id="high-volume-datastage-tests"><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">High Volume DataStage Tests</h1><div class="body"><p class="p">During the execution of a DataStage test case the data produced by a job (on one or more output links) is compared against expected test data to identify and report on any differences.</p><p class="p">When testing with large volumes of data, the comparison process may consume too much memory and cause your test job to abort with a fatal error.  The simplest approach to resolving this issue is to reduce your test data volume to the smallest number of records necessary to exercise each code path through your flow.  Doing so will ensure that your test cases execute quickly and can be easily understood and maintained.</p><p class="p">In the event that test data available to you cannot easily be reduced, the memory required by the data comparison process can be reduced by specifying a Cluster Key (based on one or more columns) in the test specification.</p></div><article class="topic nested1" aria-labelledby="ariaid-title2" id="using-cluster-keys-in-datastage-tests"><h2 class="title topictitle2" id="ariaid-title2">Using Cluster Keys in DataStage Tests</h2><div class="body"><p class="p">Setting a Cluster Key will prompt DataStage to split the actual data output and expected data into multiple, smaller subsets before the data is compared.  Data is split such that each subset will only contain records that have the same values for all columns that make up the Cluster Key.  The data are then sorted and a comparison of actual and expected data is performed using multiple, smaller operations which require less memory and are performed sequentially.</p><p class="p"><strong class="ph b">Test result behaviour</strong>: Due to the iterative nature of comparisons using a Cluster Key, each record which has differences in the Cluster Key columns will be reported as 1 added record and 1 removed record rather than shown as a single record with a change indicator.</p><p class="p">A good Cluster Key is one that results in data subsets which strike a balance between the following factors:</p><ul class="ul"><li class="li">Each subset should fit in memory during comparison. Test execution will abort when memory thresholds are breached.</li><li class="li">Are as large as possible given the memory constraint. Lots of tiny subsets will degrade comparison performance.</li></ul><p class="p">Selecting an appropriate Cluster Key might require several iterations to find a column (or combination of columns) which not only prevents Job aborts but also keeps run times acceptable.  Unless you are comparing unusually wide records, a good starting point is to aim for each subset of data to contain no more than 1,000 records and adjust the Cluster Key if memory thresholds continue to be breached.</p><blockquote class="lq"><p class="p">If you have used Interception to capture some input and / or expected test data for a DataStage Test and subsequently decide you want to apply a Cluster Key, you don’t have to re-run Interception. This is also the case if you’ve manually created any test data files. The Cluster Key is used at run time and therefore doesn’t require any additional data preparation by the user.</p></blockquote></div></article><article class="topic nested1" aria-labelledby="ariaid-title3" id="example"><h2 class="title topictitle2" id="ariaid-title3">Example</h2><div class="body"><p class="p">Consider the situation where a DataStage Test has to compare several million financial transaction records with the following schema on the 'order_out' link of stage 'ODBC_order':</p><table class="table"><caption></caption><colgroup><col><col><col><col><col></colgroup><thead class="thead"><tr class="row"><th class="entry" id="example__entry__1">Column name</th><th class="entry" id="example__entry__2">SQL type</th><th class="entry" id="example__entry__3">Length</th><th class="entry" id="example__entry__4">Scale</th><th class="entry" id="example__entry__5">Nullable</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry" headers="example__entry__1">Transaction_Date</td><td class="entry" headers="example__entry__2">Timestamp</td><td class="entry" headers="example__entry__3"> </td><td class="entry" headers="example__entry__4"> </td><td class="entry" headers="example__entry__5">No</td></tr><tr class="row"><td class="entry" headers="example__entry__1">Account_Id</td><td class="entry" headers="example__entry__2">VarChar</td><td class="entry" headers="example__entry__3">20</td><td class="entry" headers="example__entry__4"> </td><td class="entry" headers="example__entry__5">No</td></tr><tr class="row"><td class="entry" headers="example__entry__1">Type_Code</td><td class="entry" headers="example__entry__2">VarChar</td><td class="entry" headers="example__entry__3">5</td><td class="entry" headers="example__entry__4"> </td><td class="entry" headers="example__entry__5">No</td></tr><tr class="row"><td class="entry" headers="example__entry__1">Description</td><td class="entry" headers="example__entry__2">VarChar</td><td class="entry" headers="example__entry__3"> </td><td class="entry" headers="example__entry__4"> </td><td class="entry" headers="example__entry__5">Yes</td></tr><tr class="row"><td class="entry" headers="example__entry__1">Amount</td><td class="entry" headers="example__entry__2">Decimal</td><td class="entry" headers="example__entry__3">18</td><td class="entry" headers="example__entry__4">2</td><td class="entry" headers="example__entry__5">No</td></tr></tbody></table><p class="p">The test specification can be updated with a Cluster Key to enable iterative comparison of actual and expected test data.  In this example, <code class="ph codeph">Account_Id</code> and <code class="ph codeph">Type_Code</code> are defined as the compound Cluster Key:</p><pre class="pre codeblock"><code>{   …
    "then": [
        {
            "path": "ODBC_orders.csv",
            "stage": "ODBC_order",
            "link": "order_out",
            "cluster": [
                "Account_Id",
                "Type_Code"
            ]
        }
    ],
    …
}</code></pre><p class="p"><strong class="ph b">Note</strong>: Cluster Keys are specified on a per-link basis. DataStage flows with multiple output links can use any combination of clustered and non-clustered comparisons within a single test specification.</p></div><article class="topic nested2" aria-labelledby="ariaid-title4" id="caveats"><h3 class="title topictitle3" id="ariaid-title4">Caveats</h3><div class="body"><p class="p">Cluster keys should be chosen to break Actual and Expected data into clusters which are small enough to fit in memory.</p><p class="p">Note that if a Unit Test detects a value difference in a column which is a cluster key column, then the Unit Test difference report (which would normally describe the difference as a <em class="ph i"><strong class="ph b">‘modified’</strong></em> row when not using a cluster key) will now describe the difference as distinct <em class="ph i"><strong class="ph b">‘added’</strong></em> and <em class="ph i"><strong class="ph b">‘removed’</strong></em> entries.</p><p class="p">As useful as Cluster Keys are, it’s poor practice to simply apply them to every DataStage Test that has to process high data volumes. You will almost certainly find combinations of flows and data volumes in your Project where no Cluster Key will reduce the memory demands of a DataStage test enough to avoid Job aborts <strong class="ph b">(See Unit Test throws OutOfMemoryError exception)</strong>. In these situations you can manage your test data volumes by …</p><ul class="ul"><li class="li">carefully selecting a subset of records from your data sources,</li><li class="li">using the DataStage's data fabrication features, or</li><li class="li">both of these approaches in combination.</li></ul></div></article></article></article></main></body></html>